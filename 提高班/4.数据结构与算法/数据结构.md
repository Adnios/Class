# 单调栈

栈内元素保持一定单调性（单调递增或单调递减）的栈。

满足后进先出的特点。

例如实现一个单调递增的栈，比如现在有一组数10，3，7，4，12。从左到右依次入栈，则**如果栈为空或入栈元素值小于栈顶元素值，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。**单调递减的栈反之。

10入栈时，栈为空，直接入栈，栈内元素为10。

3入栈时，栈顶元素10比3大，则入栈，栈内元素为10，3。

7入栈时，栈顶元素3比7小，则栈顶元素出栈，此时栈顶元素为10，比7大，则7入栈，栈内元素为10，7。

4入栈时，栈顶元素7比4大，则入栈，栈内元素为10，7，4。

12入栈时，栈顶元素4比12小，4出栈，此时栈顶元素为7，仍比12小，栈顶元素7继续出栈，此时栈顶元素为10，仍比12小，10出栈，此时栈为空，12入栈，栈内元素为12。

应用：

1.最基础的应用就是给定一组数，针对每个数，寻找它和它右边第一个比它大的数之间有多少个数。

2.给定一序列，寻找某一子序列，使得子序列中的最小值乘以子序列的长度最大。

3.给定一序列，寻找某一子序列，使得子序列中的最小值乘以子序列所有元素和最大。

**P2866 [USACO06NOV]糟糕的一天Bad Hair Day**

 https://www.luogu.org/problem/P2866

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
stack<int> s;
int main(){
    int n;
    scanf("%d",&n);
    int h;
    LL ans=0;
    for(int i=0;i<n;i++){
        scanf("%d",&h);
        while(!s.empty()&&s.top()<=h){
            s.pop();
        }
        cout<<s.size()<<" ";
        ans+=s.size();
        s.push(h);
    }
    printf("%lld\n",ans);
    return 0;
}
```

# ST表

ST表，稀疏表

ST 表基于倍增思想，可以做到 $O(n\log n)$ 预处理， $O(1)$ 回答每个询问。但是不支持修改操作。

暴力跑的慢的原因在于检索了每一个点。

但是，如果我们预处理出每一段的最大值，就可以将效率提高很多。

令 $f[i,j]$ 表示 $[i,i+2^j-1]$ 的最大值。

显然， $f[i,0]=a[i]$

根据定义式，写出状态转移方程： $f[i,j]=\max(f[i,j-1],f[i+2^{j-1},j-1])$

我们可以这么理解：将区间 $[i,i+2^j-1]$ 分成相同的两部分

中点即为 $(i+(i+2^j-1))/2=i+2^{j-1}-1/2$

所以 $[i,i+2^j-1]$ 可以分成 $[i,i+2^{j-1}-1]$ 和 $[i+2^{j-1},i+2^j-1]$

![st1](./st1.png)

预处理终于完成了！接下来就是查询了

对于每个询问 $[x,y]$ ，我们把它分成两部分

$f[x,s]$ $f[y-2^s+1,s]$

其中 $s=\log_2{(y-x+1)}$

显然，这两个区间会重叠。但是，重叠并不会对区间最大值产生影响。同时这两个区间刚好覆盖了 $[x,y]$ ，可以保证答案的正确性。

ST 表能较好的维护区间信息，时间复杂度较低，代码量相对其他算法不大。但是，ST 表能维护的信息非常有限，不能较好地扩展，并且不支持修改操作。

**P3865 【模板】ST表**

https://www.luogu.org/problem/P3865

```c++
#include <bits/stdc++.h>
using namespace std;
const int logn = 21;
const int maxn = 2000001;
int f[maxn][logn], Logn[maxn];
void pre() {
    Logn[1] = 0;
    Logn[2] = 1;
    for (int i = 3; i < maxn; i++) {
        Logn[i] = Logn[i / 2] + 1;
    }
}
int main() {
    int n,m;
    scanf("%d%d",&n,&m);
    for (int i = 1; i <= n; i++)
        scanf("%d",&f[i][0]);
    pre();
    for (int j = 1; j <= logn; j++)
        for (int i = 1; i + (1 << j) - 1 <= n; i++)
            f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
    for (int i = 1; i <= m; i++) {
        int x, y;
        scanf("%d%d",&x,&y);
        int s = Logn[y - x + 1];
        printf("%d\n", max(f[x][s], f[y - (1 << s) + 1][s]));
    }
    return 0;
}
```

