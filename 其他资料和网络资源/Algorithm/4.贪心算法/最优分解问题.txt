问题描述：设你是一个正整数。现在要求将n分解为若干互不相同的自然数之和，且使这些自然数的乘积最大。 
 问题分析： 
 （1）对于n<=4 可以验证其分解成几个正整数的和的乘积是小于n的。 
 （2）对于n>4，能证明其能分解成几个数的和使得乘积不小于n。如果分解成1和n-1，那么对于乘积是没有帮助的；因此假设n分解成a和n-a（2<=a<=n-2），如果a和n-a仍然大于4，那么继续分解直至a,n-a小于等于4.因为每次分解都能使乘积增加，所以最优解必定是最终分解结果，也即分解出的数全是2或3。 
 （3）把m分拆成若干个互不相等的自然数的和，因数个数越多，乘积越大。为了使因数可数尽可能的多，我们把m分解成从2开始的连续的自然数之和，如果最后又剩余的数，将这个剩余的数优先考虑后面项的情况下平均分给前面的各项。 


#include<stdio.h>
int main(){
	int i,j,k;
	int num;
	int n;
	int result = 1;
	scanf("%d",&num);
	int a[100];
	a[0] = 2;
	num = num - a[0];
	n = 0;
	while(true){
		if(num > a[n]){
			a[n + 1] = a[n] + 1;
			num -= a[n + 1];
			n ++;
		}else{
			break;
		}
	}
	i = n;
	while(num > 0){
		a[i] ++;
		num --;
		i = (n + i) % (n + 1);
	}
	for(i = 0;i < n + 1;i ++){
		result *= a[i];
	}
	printf("the max is %d.",result);
	return 0;
}